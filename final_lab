1.FCFS
#include<iostream>
#include<vector>
#include<iomanip>
using namespace std;
int main() {
    int n;
    cout << "Enter number of processes: ";
    cin >> n;
    vector<int> burstTime(n);
    vector<int> waitingTime(n);
    vector<int> turnaroundTime(n);
    vector<string> processID(n);
    cout << "\nEnter process names and burst times:\n";
    for (int i = 0; i < n; i++) {
        cout << "Process " << i + 1 << " name: ";
        cin >> processID[i];
        cout << "Burst time for " << processID[i]<<": ";
        cin >> burstTime[i];
    }    
    waitingTime[0] = 0;
    for (int i = 1; i < n; i++) {
        waitingTime[i] = waitingTime[i - 1] + burstTime[i - 1];
    }
    double totalWaiting = 0, totalTurnaround = 0;
    for (int i = 0; i < n; i++) {
        turnaroundTime[i] = burstTime[i] + waitingTime[i];
        totalWaiting += waitingTime[i];
        totalTurnaround += turnaroundTime[i];
    }
    double avgWaiting = totalWaiting / n;
    double avgTurnaround = totalTurnaround / n;
    cout << "\nFCFS CPU Scheduling Results\n";
    cout << "-------------------------------------------\n";
    cout << left << setw(10) << "Process" 
         << setw(15) << "Burst Time" 
         << setw(15) << "Waiting Time" 
         << setw(15) << "Turnaround Time" << endl;
    cout << "-------------------------------------------\n";
    for (int i = 0; i < n; i++) {
        cout << left << setw(10) << processID[i]
             << setw(15) << burstTime[i]
             << setw(15) << waitingTime[i]
             << setw(15) << turnaroundTime[i] << endl;
    }
    cout << "-------------------------------------------\n";
    cout << fixed << setprecision(2);
    cout << "Average Waiting Time: " << avgWaiting << endl;
    cout << "Average Turnaround Time: " << avgTurnaround << endl;
    return 0;
}









































2.SJF
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct Process {
    int pid;            
    int arrival;        
    int burst;         
    int waiting;        
    int turnaround;     
    int completion;     
    bool done;          
};
int main() {
    int n;
    cout << "Enter the number of processes: ";
    cin >> n;
    vector<Process> p(n);
    for (int i = 0; i < n; i++) {
        cout << "\nEnter details for Process P" << i + 1 << ":\n";
        p[i].pid = i + 1;
        cout << "Arrival Time: ";
        cin >> p[i].arrival;
        cout << "Burst Time: ";
        cin >> p[i].burst;
        p[i].done = false;
    }
    int completed = 0, current_time = 0;
    float total_wait = 0, total_turnaround = 0;
    vector<int> execution_order;
    while (completed != n) {
        int idx = -1;
        int min_burst = 1e9;
        for (int i = 0; i < n; i++) {
            if (!p[i].done&&p[i].arrival <= current_time) {
                if (p[i].burst < min_burst) {
                    min_burst = p[i].burst;
                    idx = i;
                }
            }
        }
        if (idx == -1) {
            current_time++;
        } else {
            p[idx].waiting = current_time - p[idx].arrival;
            p[idx].completion = current_time + p[idx].burst;
            p[idx].turnaround = p[idx].completion - p[idx].arrival;

            total_wait += p[idx].waiting;
            total_turnaround += p[idx].turnaround;

            current_time = p[idx].completion;
            p[idx].done = true;
            execution_order.push_back(p[idx].pid);
            completed++;
        }
    }
    cout << "\n\nProcess\tArrival\tBurst\tWaiting\tTurnaround\tCompletion\n";
    for (auto &pr : p) {
        cout << "P" << pr.pid << "\t" << pr.arrival << "\t" << pr.burst << "\t"
             << pr.waiting << "\t" << pr.turnaround << "\t\t" << pr.completion << endl;
    }
    cout << "\nExecution Order: ";
    for (int id : execution_order)
        cout << "P" << id << " ";
    cout << endl;
    cout << "\nAverage Waiting Time: " << (total_wait / n);
    cout << "\nAverage Turnaround Time: " << (total_turnaround / n) << endl;
    return 0;
}





















3.Round Robin
#include<iostream>
#include<vector>
#include<queue>
#include<iomanip>
using namespace std;
struct Process {
    int pid;
    int arrival;
    int burst;
    int remaining;
    int waiting;
    int turnaround;
};
int main() {
    int n;
    cout << "Enter number of processes: ";
    cin >> n;
    vector<Process> proc(n);
    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        cout << "Enter arrival time of P" << i + 1 << ": ";
        cin >> proc[i].arrival;
        cout << "Enter burst time of P" << i + 1 << ": ";
        cin >> proc[i].burst;
        proc[i].remaining = proc[i].burst;
        proc[i].waiting = 0;
        proc[i].turnaround = 0;
    }
    int quantum;
    cout << "Enter time quantum: ";
    cin >> quantum;
    queue<int> q;
    int time = 0, completed = 0;
    vector<int> executionOrder;
    vector<bool> inQueue(n, false);
    while (completed < n) {
        for (int i = 0; i < n; i++) {
            if (proc[i].arrival<= time&&!inQueue[i]&&proc[i].remaining>0) {
                q.push(i);
                inQueue[i] = true;
            }
        }
        if (q.empty()) {
            time++;
            continue;
        }
        int idx = q.front();
        q.pop();
        inQueue[idx] = false;
        executionOrder.push_back(proc[idx].pid);
        int execTime = min(quantum, proc[idx].remaining);
        time += execTime;
        proc[idx].remaining -= execTime;
        for (int i = 0; i < n; i++) {
            if (proc[i].arrival<= time&&!inQueue[i]&&proc[i].remaining>0) {
                q.push(i);
                inQueue[i] = true;
            }
        }
        if (proc[idx].remaining>0) {
            q.push(idx);
            inQueue[idx] = true;
        } else {
            completed++;
            proc[idx].turnaround = time - proc[idx].arrival;
            proc[idx].waiting = proc[idx].turnaround - proc[idx].burst;
        }
    }
    cout << "\nOrder of execution: ";
    for (int pid : executionOrder) cout << "P" << pid << " ";
    cout << "\n\n";
    double avgWait = 0, avgTurn = 0;
    cout << left << setw(10)<<"Process"
         << setw(15)<<"Waiting Time"
         << setw(20) << "Turnaround Time" << endl;
    for (auto &p : proc) {
        cout << "P" << p.pid << setw(14) << p.waiting << setw(18) << p.turnaround << endl;
        avgWait += p.waiting;
        avgTurn += p.turnaround;
    }
    avgWait /= n;
    avgTurn /= n;
    cout << fixed << setprecision(2);
    cout << "\nAverage Waiting Time: " << avgWait;
    cout << "\nAverage Turnaround Time: " << avgTurn << endl;
    return 0;
}




4.Multi level Queue
#include<bits/stdc++.h>
using namespace std;
struct Process {
    string id;
    int at, bt, pr, wt=0, tat=0, rt=0, ct=0;
};
int main() {
    int n, tq = 3;
    cout << "Enter number of processes: ";
    cin >> n;
    vector<Process> p(n);
    for (int i = 0; i < n; i++) {
        cout << "\nProcess ID: "; cin >> p[i].id;
        cout << "Arrival Time: "; cin >> p[i].at;
        cout << "Burst Time: "; cin >> p[i].bt;
        cout << "Priority (1=High, 2=Low): "; cin >> p[i].pr;
        p[i].rt = p[i].bt;
    }
    queue<int> q1, q2;
    int time = 0, done = 0;
    vector<string> gantt;
    while (done < n) {
        for (int i = 0; i < n; i++)
            if (p[i].at == time)
                (p[i].pr == 1 ? q1 : q2).push(i);
        if (!q1.empty()) { 
            int i = q1.front(); q1.pop();
            gantt.push_back(p[i].id);
            int run = min(tq, p[i].rt);
            time += run; p[i].rt -= run;
            for (int j = 0; j < n; j++)
                if (p[j].at > time - run && p[j].at <= time)
                    (p[j].pr == 1 ? q1 : q2).push(j);
            if (p[i].rt == 0) {
                p[i].ct = time;
                p[i].tat = p[i].ct - p[i].at;
                p[i].wt = p[i].tat - p[i].bt;
                done++;
            } else q1.push(i);
        } 
        else if (!q2.empty()) { 
            int i = q2.front(); q2.pop();
            gantt.push_back(p[i].id);
            time += p[i].rt; p[i].rt = 0;
            p[i].ct = time;
            p[i].tat = p[i].ct - p[i].at;
            p[i].wt = p[i].tat - p[i].bt;
            done++;
        } 
        else time++;
    }
    cout << "\nGantt Chart: ";
    for (auto &x : gantt) cout << x << " ";
    cout << "\n\nID\tAT\tBT\tPR\tWT\tTAT\n";
    double twt=0, ttat=0;
    for (auto &x : p) {
        cout << x.id << "\t" << x.at << "\t" << x.bt << "\t" << x.pr
             << "\t" << x.wt << "\t" << x.tat << "\n";
        twt += x.wt; ttat += x.tat;
    }
    cout << "\nAvg WT=" << twt/n << "  Avg TAT=" << ttat/n<<"\n";
}





























5.Bankers Algorithm
#include<iostream>
#include<vector>
using namespace std;
int main() {
    int n, m;
    cout << "Enter number of processes and resources: ";
    cin >> n >> m;
    vector<int> avail(m);
    vector<vector<int>> max(n, vector<int>(m)), alloc(n, vector<int>(m)), need(n, vector<int>(m));
    cout << "Enter Available resources: ";
    for (int &x : avail) cin >> x;
    cout << "Enter Max matrix:\n";
    for (auto &row : max) for (int &x : row) cin >> x;
    cout << "Enter Allocation matrix:\n";
    for (auto &row : alloc) for (int &x : row) cin >> x;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];
    vector<int> work = avail, safeSeq;
    vector<bool> finish(n, false);
    for (int k = 0; k < n; k++) {
        bool found = false;
        for (int i = 0; i < n; i++) {
            if (!finish[i]) {
                bool ok = true;
                for (int j = 0; j < m; j++)
                    if (need[i][j]>work[j]) ok = false;
                if (ok) {
                    for (int j = 0; j < m; j++) work[j] += alloc[i][j];
                    finish[i] = true;
                    safeSeq.push_back(i);
                    found = true;
                }
            }
        }
        if (!found) break;
    }
    if (safeSeq.size() == n) {
        cout << "\nSystem is SAFE.\nSafe sequence: ";
        for (int i = 0; i < n; i++)
            cout << "P" << safeSeq[i]<<(i < n - 1 ? " -> " : "\n");
    } else
        cout << "\nSystem is UNSAFE.\n";
}
6.Dynamic Memory Allocation
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void firstFit(vector<int> blockSize, vector<int> processSize) {
    int m = blockSize.size();
    int n = processSize.size();
    vector<int> allocation(n, -1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                allocation[i] = j;
                blockSize[j] -= processSize[i];
                break;
            }
        }
    }
    cout << "\nFirst Fit Allocation:\nProcess No.\tProcess Size\tBlock No.\n";
    for (int i = 0; i < n; i++) {
        cout << " " << i + 1 << "\t\t" << processSize[i]<<"\t\t";
        if (allocation[i] != -1)
            cout << allocation[i] + 1;
        else
            cout << "Not Allocated";
        cout << endl;
    }
 }
 void bestFit(vector<int> blockSize, vector<int> processSize) {
    int m = blockSize.size();
    int n = processSize.size();
    vector<int> allocation(n, -1);
    for (int i = 0; i < n; i++) {
        int bestIdx = -1;
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                if (bestIdx == -1 || blockSize[j] < blockSize[bestIdx]) {
                    bestIdx = j;
                }
            }
        }
        if (bestIdx != -1) {
            allocation[i] = bestIdx;
            blockSize[bestIdx] -= processSize[i];
        }
    }
    cout << "\nBest Fit Allocation:\nProcess No.\tProcess Size\tBlock No.\n";
    for (int i = 0; i < n; i++) {
        cout << " " << i + 1 << "\t\t" << processSize[i]<<"\t\t";
        if (allocation[i] != -1)
            cout << allocation[i] + 1;
        else
            cout << "Not Allocated";
        cout << endl;
    }
 }
 void worstFit(vector<int> blockSize, vector<int> processSize) {
    int m = blockSize.size();
    int n = processSize.size();
    vector<int> allocation(n, -1);
    for (int i = 0; i < n; i++) {
        int worstIdx = -1;
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx]) {
                    worstIdx = j;
                }
            }
        }
        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            blockSize[worstIdx] -= processSize[i];
        }
    }
    cout << "\nWorst Fit Allocation:\nProcess No.\tProcess Size\tBlock No.\n";
    for (int i = 0; i < n; i++) {
        cout << " " << i + 1 << "\t\t" << processSize[i]<<"\t\t";
        if (allocation[i] != -1)
            cout << allocation[i] + 1;
        else
            cout << "Not Allocated";
        cout << endl;
    }
 }
 int main() {
    int m, n;
    cout << "Enter number of memory blocks: ";
    cin >> m;
    vector<int> blockSize(m);
    cout << "Enter size of each block:\n";
    for (int i = 0; i < m; i++) cin >> blockSize[i];
    cout << "Enter number of processes: ";
    cin >> n;
    vector<int> processSize(n);
    cout << "Enter size of each process:\n";
    for (int i = 0; i < n; i++) cin >> processSize[i];
    cout << "Choose memory allocation strategy (1-First Fit, 2-Best Fit, 3-Worst Fit): 
";
    int choice;
    cin >> choice;
    switch(choice) {
        case 1:
            firstFit(blockSize, processSize);
            break;
        case 2:
            bestFit(blockSize, processSize);
            break;
        case 3:
            worstFit(blockSize, processSize);
            break;
        default:
            cout << "Invalid choice\n";
    }
    return 0;
 }























7.FIFO
 #include <iostream>
 #include <vector>
 #include <queue>
 #include <iomanip>
 using namespace std;
 int main() {
    int numFrames;
    cout << "Enter the number of frames: ";
    cin >> numFrames;
    int numPages;
    cout << "Enter the number of pages in reference string: ";
    cin >> numPages;
    vector<int> referenceString(numPages);
    cout << "Enter the reference string: ";
    for (int i = 0; i < numPages; i++){
        cin >> referenceString[i];
    }
    vector<int> frames(numFrames, -1); 
    queue<int> fifoQueue;             
    int pageFaults = 0, pageHits = 0;
    cout << "\nReference\t";
    for (int i = 0; i < numFrames; i++){
        cout << "Frame " << i + 1 << "\t";
    }
    cout << "Status\n";
    for (int i = 0; i < numPages; i++) {
        int currentPage = referenceString[i];
        bool pageHit = false;      
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] == currentPage) {
                pageHit = true;
                break;
            }
        }
        cout << currentPage << "\t\t";
        if (pageHit) {
            pageHits++;
        } else {
            pageFaults++;         
            bool inserted = false;
            for (int j = 0; j < numFrames; j++) {
                if (frames[j] == -1) {
                    frames[j] = currentPage;
                    fifoQueue.push(j);
                    inserted = true;
                    break;
                }
            }        
            if (!inserted) {
                int indexToReplace = fifoQueue.front();
                fifoQueue.pop();
                frames[indexToReplace] = currentPage;
                fifoQueue.push(indexToReplace);
            }
        }
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] == -1)
                cout << "-\t";
            else
                cout << frames[j] << "\t";
        }
        if (pageHit)
            cout << "Page Hit";
        else
            cout << "Page Fault";
        cout << endl;
    }
    cout << "\nTotal Page Faults: " << pageFaults;
    cout << "\nTotal Page Hits: " << pageHits;
    cout << "\nPage Fault Rate: " << fixed << setprecision(3)
         << (float)pageFaults / numPages << endl;
    return 0;
 }


















8)FCFS
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head; cout<<"Enter number of requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter initial head position: ";cin>>head;
    int seek=0, pos=head;
    cout<<"\nSeek Sequence: "<<pos;
    for(int r:rq){ seek+=abs(r-pos); pos=r; cout<<" ->"<<r; }
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}


9)SSTF
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head; cout<<"Enter number of requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter initial head: ";cin>>head;
    vector<bool> done(n,false); int seek=0,pos=head;
    cout<<"\nSeek Sequence: "<<pos;
    for(int i=0;i<n;i++){
        int idx=-1,mn=1e9;
        for(int j=0;j<n;j++)
            if(!done[j] && abs(rq[j]-pos)<mn){mn=abs(rq[j]-pos); idx=j;}
        done[idx]=true; seek+=mn; pos=rq[idx]; cout<<" ->"<<pos;
    }
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}















10)SCAN
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head,dir; cout<<"Enter number of requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter head position and direction (0=left,1=right): ";
    cin>>head>>dir; rq.push_back(head);
    sort(rq.begin(),rq.end());
    int idx=find(rq.begin(),rq.end(),head)-rq.begin();
    int seek=0; vector<int> seq;
    if(dir){ for(int i=idx;i<rq.size();i++) seq.push_back(rq[i]);
             for(int i=idx-1;i>=0;i--) seq.push_back(rq[i]); }
    else { for(int i=idx;i>=0;i--) seq.push_back(rq[i]);
           for(int i=idx+1;i<rq.size();i++) seq.push_back(rq[i]); }
    for(int i=1;i<seq.size();i++) seek+=abs(seq[i]-seq[i-1]);
    cout<<"\nSeek Sequence: "; for(int x:seq) cout<<x<<" ";
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}



11)C-SCAN

#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head; cout<<"Enter number of requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter head: ";cin>>head;
    int disk=200; rq.push_back(head);
    sort(rq.begin(),rq.end());
    int idx=find(rq.begin(),rq.end(),head)-rq.begin();
    vector<int> seq; int seek=0;
    for(int i=idx;i<rq.size();i++) seq.push_back(rq[i]);
    for(int i=0;i<idx;i++) seq.push_back(rq[i]);
    for(int i=1;i<seq.size();i++) seek+=abs(seq[i]-seq[i-1]);
    cout<<"\nSeek Sequence: "; for(int x:seq) cout<<x<<" ";
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}






12)LOOK
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head,dir; cout<<"Enter requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter head and dir (0=left,1=right): ";cin>>head>>dir;
    sort(rq.begin(),rq.end());
    int idx=lower_bound(rq.begin(),rq.end(),head)-rq.begin();
    vector<int> seq; int seek=0;
    if(dir){ for(int i=idx;i<n;i++) seq.push_back(rq[i]);
             for(int i=idx-1;i>=0;i--) seq.push_back(rq[i]); }
    else { for(int i=idx-1;i>=0;i--) seq.push_back(rq[i]);
           for(int i=idx;i<n;i++) seq.push_back(rq[i]); }
    seq.insert(seq.begin(),head);
    for(int i=1;i<seq.size();i++) seek+=abs(seq[i]-seq[i-1]);
    cout<<"\nSeek Sequence: "; for(int x:seq) cout<<x<<" ";
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}



13)C-LOOK
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,head; cout<<"Enter number of requests: ";cin>>n;
    vector<int> rq(n); for(int&i:rq)cin>>i;
    cout<<"Enter head: ";cin>>head;
    sort(rq.begin(),rq.end());
    int idx=lower_bound(rq.begin(),rq.end(),head)-rq.begin();
    vector<int> seq; int seek=0;
    for(int i=idx;i<n;i++) seq.push_back(rq[i]);
    for(int i=0;i<idx;i++) seq.push_back(rq[i]);
    seq.insert(seq.begin(),head);
    for(int i=1;i<seq.size();i++) seek+=abs(seq[i]-seq[i-1]);
    cout<<"\nSeek Sequence: "; for(int x:seq) cout<<x<<" ";
    cout<<"\nTotal Seek Time = "<<seek<<"\n";
}




